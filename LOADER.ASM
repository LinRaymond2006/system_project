%INCLUDE "ADDR_CFG.INC"
%INCLUDE "FAT32HEADERS_ADDR.INC"
%DEFINE TMP_PAGE_TABLE_BASE (0X90000)

%DEFINE DATASZ32 DB 0X66
%DEFINE DATASZ64 DB 0X66
[BITS 16]
[ORG LOADERBASE]
;DISK_PACKET: 0X500~0X700 (DISK_PACKET_SIZE:0X10)
;MEM_STRUCT: 0X7C00~0X7E00 (MEM_STRUCT_SIZE:0X200)
;MEM_STRUCT WILL OVERWRITE MASTER BOOT RECORD
;VBE_STRUCT:
%DEFINE MEM_STRUCT_BASE 0X500


INIT:
    MOV SP, 0X7C00      ;RESET THE STACK
    MOV AX, 0XB800
    MOV GS, AX      ;TMP TEXT FRAME BUFFER SEGMENT REGISTER
    CALL DO_CLEAR_SCR
    CALL DO_DISABLE_CURSOR

%DEFINE SMAP_MAGIC 0X534D4150



START_GET_MEM_STRUCT:
    XOR EBX, EBX
    MOV ES, BX      ;ES=0 (STRUCTURE ADDRESS: 0X0000:0X0700 )
    MOV DI, MEM_STRUCT_BASE

    .GET_MEM_STRUCT_LOOP:
        MOV EAX, DWORD 0XE820
        MOV ECX, DWORD 20
        MOV EDX, DWORD SMAP_MAGIC
        INT 0X15
        JC .GET_MEM_STRUCT_FAILED
        INC BYTE [MEM_STRUCT_COUNT]
        ADD DI, 20
        CMP EBX, 0
        JNE .GET_MEM_STRUCT_LOOP
        JMP .GET_MEM_STRUCT_DONE
    .GET_MEM_STRUCT_FAILED:
        ;AH=ERROR CODE (0X80:INVALID COMMAND;0X86 = "E820 NOT SUPPORTED" )
        JMP $       ;HALT FOR NOW, TAKE FURTHER ACTION IN FUTURE (PRINT LOG)
    .GET_MEM_STRUCT_DONE:

DO_ENABLE_A20_FASTGATE:
	IN AL, 0X92
	OR AL, 00000010B
	OUT 0X92, AL



SETUP_PMODE:

    DATASZ32
    LGDT [GDT32PTR]

    DATASZ32
    LIDT [IDT32PTR]
    MOV EAX, CR0
    OR EAX, 1
    MOV CR0, EAX
    JMP DWORD SELECTOR_CODE32:PMODE_ENTRY

[BITS 32]

PMODE_ENTRY:
	mov	ax,	0x10
	mov	ds,	ax
	mov	es,	ax
	mov	fs,	ax
	mov	ss,	ax
	mov	esp,	0x7c00

;ROOT DIRECTORY: 0X7E00~0X100000 (ABLE TO STORE 1985 SECTORS)
%UNDEF ROOTDIRBASE
%UNDEF FATBASE
%UNDEF FATCHAINBASE
%DEFINE ROOTDIRBASE	0x1700
%DEFINE FATBASE		0X1700
%DEFINE FATCHAINBASE 0X700

%DEFINE SFNSIZE	32
%DEFINE FILENAME_LENGTH 11

;=======================
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
CALCULATE_FIRSTDATASECTOR32:

;FAT32:
;FIRSTDATASECTOR = BPB_RESVDSECCNT + (BPB_NUMFATS * FATSZ32)

;(BPB_NUMFATS * FATSZ32)
MOV ECX, DWORD [BPB_FATSZ32]
MOVZX EAX, BYTE [BPB_NUMFATS]
MUL ECX

;+BPB_RESVDSECCNT
MOVZX EDX, WORD [BPB_RESVDSECCNT]
ADD EAX, EDX

;THIS WILL RAISE A "MISMATCH IN OPERAND SIZES" EXCEPTION ON COMPILE TIME
;ADD EAX, WORD [BPB_RESVDSECCNT]


MOV DWORD [FIRSTDATASECTOR], EAX


LOAD_ROOTDIR32:
;FUNCTION "NXT_CLUSTER32"
;EDX:CLUSTER NUMBER (AS A CALLER, THE CLUSTER NUMBER STARTS FROM 0)
;EBP:WHERE TO GO IF RECIEVE "EOF" VALUE

;RETURNS:
;EAX: THE SECTOR NUMBER OF THE CLUSTER
;EDX:NEXT CLUSTER NUMBER (THE CLUSTER NUMBER STARTS FROM 0)

;NECESSARY CONDITIONS:
;MACRO "FATBASE" HAVE TO BE DEFINED

;EAX IS NOW FIRSTDATASECTOR, THEREFORE NOT SET AGAIN

.LOAD_INTO_MEM:

MOV EBX, ROOTDIRBASE
MOVZX ECX, BYTE [BPB_SECPERCLUS]
CALL READ_ATA32

;CX IS NOW BPB_SECPERCLUS
;CHECKOUT FILES IN THE FIRST CLUSTER (NOTE:ONLY SEARCH FOR THE FIRST ROOTDIRECTORY CLUSTER)
.COMPARE_FILENAME:
%DEFINE SFNSHIFT 5



.SETUP:
MOV ESI, ROOTDIRBASE
.COMPARE_LOOP:
	MOV ECX, FILENAME_LENGTH
	MOV EDI, KERNEL_FILENAME
	MOV EDX, ESI
	DB 0XF3 , 0XA6	; repe cmpsb byte ptr [esi], byte ptr es:[edi]
	JECXZ FILE_FOUND32
	;ELSE: (IF FILE NOT FOUND...)
	MOV ESI, EDX
	ADD ESI, SFNSIZE

	MOVZX EDX, BYTE [BPB_SECPERCLUS]
	ADD EDX, ROOTDIRBASE
	CMP EDX, ESI
	;JE FILE_LOST
	JE $
	JMP .COMPARE_LOOP


FILE_FOUND32:		;IF FILE FOUND:LOAD THE FAT TABLE
.GET_FIRSTCLUSTER:
	;ESI IS NOW THE FILE ENTRY
	;THE START OF THE SFN ENTRY (OFFSET 0)=ESI-11
	;DIR_FSTCLUSHI STARTS FROM OFFSET 20, SIZE 2 (16BITS)
	;DIR_FSTCLUSLO STARTS FROM OFFSET 26, SIZE 2 (16BITS)
	;ALL IN ALL:
	;DIR_FSTCLUSHI=ESI-11+20=ESI+9
	;DIR_FSTCLUSLO=ESI-11+26=ESI+15
	MOV ESI, EDX
	MOV DX, WORD [ESI+20]
	SHL EDX, 16
	MOVZX ECX, WORD [ESI+26]
	ADD EDX, ECX






;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
LOAD_FATTABLE32:					;IF THE FILE IS FOUND, THAN THE FAT TABLE SHOULD BE LOADED, OTHERWISE, THERE IS NO NEED TO LOAD THE TABLE
;FUNCTION: "READ_ATA32"
;EAX:SECTOR OFFSET
;EBX:BUFFER LOCATION
;CX:NUMBER OF SECTORS TO READ
MOVZX EAX, WORD [BPB_RESVDSECCNT]
MOV EBX, FATBASE
;UNFORTUNATELY, THE INTURRUPT FUNCTION ONLY PROVIDES 16-BIT SECTOR COUNT(WHICH IS STORE IN CX REGISTER)
;SO, IF THE FAT TABLE IS LARGE, THE UPPER PART WILL NOT BE LOADED INSIDE MEMORY
;PLUS, THE CONVENTIONAL MEMORY (0X7E00~0X100000) IS ONLY ABLE TO HELD 1985 SECTORS

;CHECK THE FATSZ(NOTE:IN SECTOR OF 512)
CMP EAX, 1985
JBE .SMALL_FAT
;ELSE: THE FAT IS BIGGER THAN 1985 SECTORS
;THEN: LOAD THE FIRST 1985 SECTORS FROM THE DISK
MOV EAX, 1985

.SMALL_FAT:
MOV ECX, DWORD [BPB_FATSZ32]

CALL READ_ATA32



LINK_FATCHAIN32:
MOV SI, FATCHAINBASE	;SI IS ENOUGH FOR THE LOWER 1MB
MOV EBP, LOAD_KERNEL
;FUNCTION "NXT_CLUSTER32"
;EDX:CLUSTER NUMBER (AS A CALLER, THE CLUSTER NUMBER STARTS FROM 0)
;EBP:WHERE TO GO IF RECIEVE "EOF" VALUE

;RETURNS:
;EDX:NEXT CLUSTER NUMBER (THE CLUSTER NUMBER STARTS FROM 0)

;NECESSARY CONDITIONS:
;MACRO "FATBASE" HAVE TO BE DEFINED

;EDX IS NOW THE FIRST CLUSTER OF THE FILE, NOT SET AGAIN NOW
%DEFINE FAT_ENTRY_SIZE 4
PUSH WORD LOAD_KERNEL
MOV EBP, PREPARE_LOAD_KERNEL	;IF THE CHAIN HITS EOF, THAN GO TO THE NEXT STEP "LOAD_KERNEL"
MOV EAX, EDX				;BOTH CMP_STOP32 AND NXT_CLUSTER32 TAKE EAX AS ARGUMENT
.CREATE_CHAIN:
	MOV DWORD [SI], EAX
	ADD SI, FAT_ENTRY_SIZE

	CALL NXT_CLUSTER32
	CALL CMP_STOP32			;FIXED
	JMP .CREATE_CHAIN



;;;;;;;;;;;;;;;;;;;;;;

PREPARE_LOAD_KERNEL:
MOV EBX, KERNELBASE		;LOADERBASE ACTUALLY
MOV SI, FATCHAINBASE
LOAD_KERNEL:
	;FIRST TWO CLUSTERS HAVE BEEN IGNORED???
	;;;;;;;;;;;;LAB;;;;;;;;;;;;;;;
	MOV EAX, DWORD [SI]
	CALL CLUSTER2SECTOR32
	MOVZX CX, BYTE [BPB_SECPERCLUS]
	CALL READ_ATA32
	ADD SI, 4
	MOV EAX, DWORD [SI]
	MOV EBP, KERNELBASE
	CALL CMP_STOP32
	;IF NOT EOF...

	MOVZX EBP, BYTE [BPB_SECPERCLUS]
	SHL EBP, 9	;*512(SECTOR SIZE IN BYTES)
	ADD EBX, EBP

	JMP LOAD_KERNEL

JMP $
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

[SECTION DATA]
MEM_STRUCT_COUNT: DB 0
FIRSTDATASECTOR: DD 0
WORD_PRINTED: DW 0
CURSOR_PTR: DW 0

[SECTION .STRINGS]
KERNEL_FILENAME: DB "KERNEL  SYS"

;END OF STRING
%DEFINE EOS (0X00)
%DEFINE CHAR_SPEC_N 10
%DEFINE CHAR_SPEC_B 8

LOG_CPUID_NOT_SUPPORTED: DB "INSTRUCTION 'CPUID' NOT SUPPORTED, HALT", CHAR_SPEC_N,"INSTRUCTION 'CPUID' NOT SUPPORTED, HALT", CHAR_SPEC_N, EOS
LOG_LONG_MODE_NOT_SUPPORTED: DB "CPUID.LM CLEARED, HALT", EOS

[SECTION .GDT]

LABEL_GDT32:  DD 0,0
LABEL_DESCRIPTOR_CODE32:    DD 0X0000FFFF, 0X00CF9A00
LABEL_DESCRIPTOR_DATA32:    DD 0X0000FFFF, 0X00CF9200
LABLE_GDT32_END:
GDT32LEN    EQU     (LABLE_GDT32_END - LABEL_GDT32)
GDT32LIM    EQU     (GDT32LEN-1)
GDT32PTR:
    DW GDT32LIM
    DD LABEL_GDT32
SELECTOR_CODE32 EQU     (LABEL_DESCRIPTOR_CODE32-LABEL_GDT32)
SELECTOR_DATA32 EQU     (LABEL_DESCRIPTOR_DATA32-LABEL_GDT32)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

[SECTION .IDT]
LABEL_IDT32:
    TIMES 0X50 DQ 0
LABEL_IDT32_END:
IDT32LEN    EQU     (LABEL_IDT32_END - LABEL_IDT32)
IDT32LIM    EQU     (IDT32LEN-1)
IDT32PTR:
    DW IDT32LIM
    DD LABEL_IDT32



[SECTION SUBROUTINE]

%INCLUDE "LOADER_LIB.INC"
%INCLUDE "MAIN32.INC"